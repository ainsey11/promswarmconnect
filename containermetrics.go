package main

import (
	"context"
	"encoding/json"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/client"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"io/ioutil"
	"log"
	"net/http"
	"sync"
	"time"
)

/*	Architecture:

	- We launch one goroutine that polls (syncs) containers from Docker that we should scrape stats for
	- For each container we launch a goroutine, which will poll Docker API for statistics
	  and submit them back to main for adding to prometheus metrics

	+-----------------------+           +--------------------------+
	|                       |           |                          |
	| containerListSyncTask |       +---+ containerStatsPollerTask |
	|                       |       |   | (container 1)            |
	+----------+------------+       |   |                          |
	           |                    |   +--------------------------+
	           |                    |
	           |         +------+   |   +--------------------------+
	           |         |      |   |   |                          |
	           +---------+ main +-------+ containerStatsPollerTask |
	                     |      |   |   | (container 2)            |
	                     +------+   |   |                          |
	                                |   +--------------------------+
	                                |
	                                |   +--------------------------+
	                                |   |                          |
	                                |   | containerStatsPollerTask |
	                                +---+ (container 3)            |
	                                    |                          |
	                                    +--------------------------+

*/

func containerListSyncTask(cli *client.Client, addedContainerCh chan ScrapeTarget, removedContainerCh chan ScrapeTarget) {
	targets := map[string]ScrapeTarget{}

	for {
		containers, err := cli.ContainerList(context.Background(), types.ContainerListOptions{})
		if err != nil {
			panic(err)
			time.Sleep(5 * time.Second)
			continue
		}

		unmentionedTargets := map[string]bool{}

		for containerId, _ := range targets {
			unmentionedTargets[containerId] = true
		}

		for _, container := range containers {
			// "database"
			serviceName, hasServiceLabel := container.Labels["com.docker.swarm.service.name"]
			// "database.1"
			taskName, hasTaskName := container.Labels["com.docker.swarm.task.name"]

			if !hasServiceLabel || !hasTaskName {
				continue
			}

			target := ScrapeTarget{serviceName, container.ID, taskName}

			_, seenBefore := targets[target.ContainerID]
			if !seenBefore { // => is new
				addedContainerCh <- target
			}

			targets[target.ContainerID] = target

			delete(unmentionedTargets, target.ContainerID)
		}

		for unmentionedContainerId, _ := range unmentionedTargets {
			removedContainerCh <- targets[unmentionedContainerId]

			delete(targets, unmentionedContainerId)
		}

		time.Sleep(5 * time.Second)
	}
}

func containerStatsPollerTask(cli *client.Client, target ScrapeTarget, containerStatsResultCh chan StatsResult, abortCh chan bool) {
	for {
		// handle abort
		select {
		case dummy := <-abortCh:
			_ = dummy
			return

		default:
		}

		time.Sleep(5 * time.Second)

		cs, err := cli.ContainerStats(context.Background(), target.ContainerID, false)
		if err != nil {
			panic(err)
		}

		jsonStats, err := ioutil.ReadAll(cs.Body)
		if err != nil {
			panic(err)
		}

		cs.Body.Close()

		stuff := StatsJsonAutoGenerated{}
		err = json.Unmarshal(jsonStats, &stuff)
		if err != nil {
			panic(err)
		}

		sr := StatsResult{target, stuff}

		containerStatsResultCh <- sr
	}
}

func promHttpTask() {
	http.Handle("/metrics", promhttp.Handler())
	log.Fatal(http.ListenAndServe(":80", nil))
}

func containerMetricsTask(cli *client.Client, wg *sync.WaitGroup) {
	defer wg.Done()

	log.Printf("containerMetricsTask: starting")

	addedContainerCh := make(chan ScrapeTarget)
	removedContainerCh := make(chan ScrapeTarget)
	containerStatsResultCh := make(chan StatsResult)

	go containerListSyncTask(cli, addedContainerCh, removedContainerCh)

	abortChannels := make(map[string]chan bool)

	go promHttpTask()

	// for more details on exporting container metrics:
	// https://github.com/docker-infra/container_exporter/blob/master/exporter.go

	container_memory_usage_bytes := prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Name: "container_memory_usage_bytes",
		Help: "container_memory_usage_bytes",
	}, []string{"job", "instance"})
	prometheus.MustRegister(container_memory_usage_bytes)

	container_cpu_usage_seconds_total := prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Name: "container_cpu_usage_seconds_total",
		Help: "container_cpu_usage_seconds_total",
	}, []string{"job", "instance"})
	prometheus.MustRegister(container_cpu_usage_seconds_total)

	container_net_rx := prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Name: "container_net_rx",
		Help: "container_net_rx",
	}, []string{"job", "instance"})
	prometheus.MustRegister(container_net_rx)

	container_net_tx := prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Name: "container_net_tx",
		Help: "container_net_tx",
	}, []string{"job", "instance"})
	prometheus.MustRegister(container_net_tx)

	for {
		select {
		case addedContainer := <-addedContainerCh:
			log.Printf("containerMetricsTask: added   | %s", addedContainer.ServiceID)

			abortChannels[addedContainer.ContainerID] = make(chan bool, 1)

			go containerStatsPollerTask(cli, addedContainer, containerStatsResultCh, abortChannels[addedContainer.ContainerID])

		case removedContainer := <-removedContainerCh:
			log.Printf("containerMetricsTask: removed | %s", removedContainer.ServiceID)

			// ask that poller to stop
			abortChannels[removedContainer.ContainerID] <- true

		case result := <-containerStatsResultCh:
			container_memory_usage_bytes.With(prometheus.Labels{
				"job":      result.Target.ServiceID,
				"instance": result.Target.TaskCode,
			}).Set(float64(result.Stats.MemoryStats.Usage))

			container_cpu_usage_seconds_total.With(prometheus.Labels{
				"job":      result.Target.ServiceID,
				"instance": result.Target.TaskCode,
			}).Set(float64(result.Stats.CPUStats.CPUUsage.TotalUsage) / float64(time.Second))

			// aggregated over all NICs
			aggregatedTx := 0.0
			aggregatedRx := 0.0

			for _, stats := range result.Stats.Networks {
				aggregatedTx += float64(stats.TxBytes)
				aggregatedRx += float64(stats.RxBytes)
			}

			container_net_tx.With(prometheus.Labels{
				"job":      result.Target.ServiceID,
				"instance": result.Target.TaskCode,
			}).Set(aggregatedTx)

			container_net_rx.With(prometheus.Labels{
				"job":      result.Target.ServiceID,
				"instance": result.Target.TaskCode,
			}).Set(aggregatedRx)
		}
	}
}
